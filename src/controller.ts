import * as fs from 'fs';
import {INetworkUtils, initNetworkUtils} from './utils/networkUtils';

const mebiByteInBytes: number = 1024 * 1024; // 1 MiB = 1024 * 1024 bytes

export class Controller {

    networkUtils: INetworkUtils;

    constructor(networkUtils: INetworkUtils) {
        this.networkUtils = networkUtils;
    }

    /**
     * Return a promise to fetch a data chunk
     * @param {String}      url                 The url to fetch
     * @param {int}         startBytes          Bytes to start chunk at
     * @param {int}         chunkSizeInBytes    Bytes to stop chunk at
     */
    getChunk(url: string, startBytes: number, chunkSizeInBytes: number): Promise<any> {
        return this.networkUtils.http({
            method: 'get',
            url: url,
            headers: {
                'Range': 'bytes=' + startBytes + '-' + (startBytes + chunkSizeInBytes - 1)
            },
            responseType: "arraybuffer"
        }).catch(err => {
            // Throw an informative exception
            throw err;
        });
    }

    /**
     * Throw an exception if the file exists
     * @param {string} fileName
     * @returns {boolean}
     */
    validateFile(fileName: string): boolean {
        if (fs.existsSync(fileName)) {
            // Throw an informative exception
            throw {
                name: 'FileExists',
                message: fileName + " already exists"
            };
        }
        return true;
    }

    /**
     * Perform a multi get for the given url
     * @param   {string} url                  The url of the file to be downloaded
     * @param   {string?} fileName            The name of the file. If none is given a default value is used.
     * @param   {number?} parts               The number of parts to download
     * @param   {number?} chunkSizeInBytes    The size of the chunks to be downloaded in bytes
     * @throws   {Error}                       Network and fs Errors
     */
    multiGet(url: string, fileName: string, parts: number = 4, chunkSizeInBytes: number = mebiByteInBytes): Promise<any> {

        // Set the default file name to the name on the path
        if (fileName === "") {
            fileName = url.split('/').pop();
        }

        // Validate that the file does *NOT* exist
        this.validateFile(fileName);

        // Open up our requests asynchronously and pool them in the requests array in order. This is effectively
        // parallelism in javascript networking.
        let requests = [];
        for (let i = 0; i < parts; i++) {
            let request = this.getChunk(url, i * chunkSizeInBytes, chunkSizeInBytes)
                .then(resp => {

                    // Indicate the progress with a '.' when a chunk has been downloaded
                    process.stdout.write('.');
                    return resp;
                });
            requests.push(request);
        }

        // Call the ordered promise handler and return the promise generated by it
        return this.networkUtils.httpResolveAllInOrder(requests).then(chunks => {

            /**
             * We get back the ordered chunks
             */

            // Open a write stream with the appropriate file name and error handling
            let writeStream = fs.createWriteStream(fileName)
                    .on('error', err => {
                        // Let the user know that a file stream error occurred and allow fs to gracefully terminate process
                        throw err;
                    })
                    .on('finish', () => {
                        // Let the user know the program has completed
                        process.stdout.write('done\n');
                    });

            // Write each chunks data, which is an array buffer, into the write stream
            chunks.map(chunk => writeStream.write(chunk.data));

            // Close the stream
            writeStream.end();
        });
    }
}

export function initController() {
    return new Controller(initNetworkUtils());
}